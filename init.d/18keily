#!/system/xbin/bash

# keilyd: A easy-to-share system logs tool for Android

#   Copyright (C) 2015  Oever Gonzalez

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 3 of the License, or
#   (at your option) any later version.

#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.

# keilyd is a BASH daemon that constantely dumps several system
# files in a easy-to-share zip in the /sdcard of almost any
# Android device. In order to get keilyd working, the script
# must have to live in ../init.d; the device must have init.d
# support (implies busybox) and must have bash installed in
# ../xbin

# This script runs only in bash, it's not compatible with dash,
# zsh, or even with sh

# NoTengoBattery - 2015

# A value different than "Y" will disable Keilyd
if [ -z "$ENABLED" ];
then
    ENABLED="Y"
fi

## This is the daemon registry
DNAME="$(basename $0)"
## Dumps the processes
PNAME="process"
## Dumps the kernel log
KNAME="kinfo"
## Dumps logcat
CNAME="logcat"
## Dumps the cpuinfo
CPUNAME="cpuinfo"
## Dumps "build.prop"
BNAME="build_prop"
## Dumps the last kernel log
LASTKMSG="last_kmsg"
## Dumps "sysctl.conf"
SYSCTL="sysctl_conf"
## Output of 'df'
DF="df"

## MINS is the time in minutes that keilyd must wait untill it's
## dumps the files again. ONLY INTS
if [ -z "$MINS" ];
then
    MINS=15
fi
SECS=$(($MINS * 60))

## Date and time for the registry
function dtime (){
    DATE="$(date +%m%d%y@%H:%M:%S)"
    echo $DATE
}
## Date and time for the timestamp in the filename
function namedate (){
    DATE="-$(date +%m%d%y-%H.%M)"
    echo $DATE
}
function OK (){
    OK="[ -DONE-$(dtime) ]"
    echo $OK
}

function WARN (){
    WARN="[ -WARN-$(dtime) ]"
    echo $WARN
}
function ERR (){
    ERR="[ --ERR-$(dtime) ]"
    echo $ERR
}
## Prints a usefull separator between lines
function separator (){
    CHAR="#"
    SEP=""
    for s in {1..64}
    do
        SEP=$SEP$CHAR
    done
    echo "$SEP"
}

SEPA=$(separator)

## FILEDIR points to the very top of the working directory.
## TMPDIR and OUTDIR are subdirectories
if [ -z "$FILEDIR" ];
then
    FILEDIR=/sdcard/$(basename $0)
fi
TMPDIR=$FILEDIR/tmp
OUTDIR=$FILEDIR/out
INITD=$TMPDIR/init.d

CURR_PROFIX=_curr
PACKED_PROFIX=.zip
LAST_PROFIX=_last
NORM_PROFIX=.txt

# Pointers to the last and current ZIP
LAST_ZIP_PREFIX=$DNAME$LAST_PROFIX
LOG_ZIP_PREFIX=$DNAME$CURR_PROFIX
LOG_PACKED=$OUTDIR/$LOG_ZIP_PREFIX$(namedate)$PACKED_PROFIX

## Points to the log file and to all specific files listed above
DELOG=$TMPDIR/$DNAME$CURR_PROFIX$NORM_PROFIX
REG_LIST=( $PNAME$NORM_PROFIX $KNAME$NORM_PROFIX $CNAME$NORM_PROFIX $CPUNAME$NORM_PROFIX $BNAME$NORM_PROFIX $LASTKMSG$NORM_PROFIX $SYSCTL$NORM_PROFIX $DF$NORM_PROFIX )

## Generate a RANDOM id to identify the script and the daemon as different stuff
ID=$RANDOM

function makezip (){
    cd $TMPDIR && echo "$(OK) Here: $TMPDIR"
    rm $1 && echo "$(OK) Deleted $1"
    zip -r -9 $DNAME$CURR_PROFIX$PACKED_PROFIX * && echo "$(OK) Zipped --> $(*) <-- in $DNAME$CURR_PROFIX$PACKED_PROFIX"
    mv $DNAME$CURR_PROFIX$PACKED_PROFIX $1 && echo "$(OK) Moved $DNAME$CURR_PROFIX$PACKED_PROFIX to $1"
}

## EXIT IF Keilyd is disabled
if [ "$ENABLED" != "Y" ];
then
    echo "Keilyd soft disabled, exit NOW!"
    exit 0
fi

## BASH VERSION: For now, ONLY 4.3 is supported
if [[ !($(bash -version) =~ "4.3") ]];
then
    echo "BASH version UNSUPORTED:
    $(bash -version | grep "GNU bash")"
    exit 0
fi

PERM="$(touch /test && export OK4="Y" || export OK4="N")"
touch /test &> /dev/null && export OK4="Y" || export OK4="N"
if [[ "$OK4" == "N" && "ermis" =~ $PERM ]];
then
    echo "$(ERR) FATAL! Permision Denied!!"
    exit 0
else
    echo "$(OK) Enough permissions!"
    rm -rf /test
fi

if [[ $1 = --snap ||  -z $1 ]];
then
    MAKEDIR=""
    ls $FILEDIR &> /dev/null || MAKEDIR="Y"
    ls $OUTDIR &> /dev/null || MAKEDIR="Y"
    ls $INITD &> /dev/null || MAKEDIR="Y"
    ls $TMPDIR &> /dev/null || MAKEDIR="Y"
    if [ -z $MAKEDIR ];
    then
        ## Quitar el directorio TMP
        if [ -z $1 ];
        then
            THISDIR=$(pwd)
            pwd
            cd $OUTDIR
            echo $OUTDIR
            ## Pack the LATEST files in /tmp before delete all information, so
            ## its allways up-to-date
            LOG_PACKED=$OUTDIR/$(ls $LOG_ZIP_PREFIX*)
            echo $separator >> $DELOG
            echo "$(OK) This is the very last version of this file" >> $DELOG
            makezip $LOG_PACKED
            cd $THISDIR
            rm -rf $TMPDIR
            mkdir $TMPDIR
            echo "$(OK) Launched #$ID" > $DELOG
            echo "$(OK) Deleted all deprecated filles" >> $DELOG
        else
           echo "$(separator)" >> $DELOG
           echo "$(OK) Launched #$ID" >> $DELOG
           echo "$(WARN) Taking a Snapshot of the system logs..." >> $DELOG
           echo "$(WARN) 'Locking' the daemon!!!" >> $DELOG
           touch $TMPDIR/locked
        fi
        echo "$(OK) cmdline: '$0 $@'" >> $DELOG
        THISDIR=$(pwd)
        echo "$(OK) Here: '$THISDIR'" >> $DELOG
        cd $OUTDIR
        echo "$(OK) Here: '$OUTDIR'" >> $DELOG
        if [ -z $1 ];
        then
            ## Borro los "last" inutiles
            FIL=$(ls $LAST_ZIP_PREFIX*)
            rm $LAST_ZIP_PREFIX* && echo "$(OK) Deleted $FIL" >> $DELOG
            ## Muevo los "current" a Last antes de sobrescribirlos
            FIL=$(ls $LOG_ZIP_PREFIX*)
            DAT="${FIL: -17:17}"
            mv $LOG_ZIP_PREFIX* $LAST_ZIP_PREFIX$DAT && echo "$(OK) Moved $FIL to $LAST_ZIP_PREFIX$DAT" >> $DELOG
            for i in "${REG_LIST[@]}"
            do
                echo "" > $TMPDIR/$i && echo "$(OK) File $TMPDIR/$i initialized" >> $DELOG || echo "$(ERR) Can't write $TMPDIR/$i" >> $DELOG
            done
        fi
        cd $THISDIR
    else
        ## No existe la carpeta en /sdcard
        mkdir $FILEDIR && echo "$(OK) TOP DIR CREATED" || OK="N"
        if [ "$OK" == "N" ];
        then
            echo "$(ERR) FATAL! Can't create top dir!!"
            exit 0
        fi
        mkdir $TMPDIR
        mkdir $OUTDIR
        mkdir $INITD
        echo "$(OK) Launched #$ID" > $DELOG
        echo "$(OK) cmdline: '$0 $@'" >> $DELOG
        echo "$(OK) Created working dirs." >> $DELOG
        echo "$(OK) Relaunch keilyd from first startup." >> $DELOG
        setsid $0 $@ &>>/dev/null < /dev/null &
        exit 0
    fi
    echo "$(OK) Keilyd preload successfully" >> $DELOG
    setsid $0 --demonize $1 &>>$DELOG < $DELOG &
elif [[ $1 == --demonize ]];
## Keilyd as daemon
then
    echo "$(OK) Launched (daemon) #$ID"
    echo "$(OK) cmdline: '$0 $@'" >> $DELOG
    echo "$(OK) Daemon started."
    WHOAMI=$(whoami)
    if [ "$WHOAMI" != "root" ];
    then
        echo "$(ERR) Keilyd must be launched as root, '$WHOAMI' is not root."
    else
        echo "$(OK) Keily#$ID have root privilegies"
        cd $FILEDIR && echo "$(OK) Here: $FILEDIR" || echo "$(ERR) Can't enter in $FILEDIR"
        THISDIR=$(pwd)
        if [ "$THISDIR" = "$FILEDIR" ];
        then
            ## When SCLEAN reaches SLIMIT, the daemon log will be cleaned (in order to keep it small)
            SCLEAN=0
            if [ -z "$SLIMIT" ];
            then
                # 48 times every 15 min is 12 hours
                SLIMIT=48
            fi
            ## Dump all files
            while [ -z "" ];
                SCLEAN=$(($SCLEAN + 1))
                if [ "$SCLEAN" = "$SLIMIT" ];
                then
                    SCLEAN=0
                    mv $DELOG $OUTDIR/ktmp
                    rm -rf $TMPDIR
                    mkdir $TMPDIR
                    mv $OUTDIR/ktmp $DELOG
                    echo "$(WARN) Keilyd has cleaned the daemon log file and directory" > $DELOG
                fi
                do
                     for j in "${REG_LIST[@]}"
                     do
                         echo "$(OK) All the info is to being dumped in $j."
                         SUCESS=""
                         echo "$(OK) SOF" > $TMPDIR/$j && SUCESS="Y" || SUCESS="N"
                         if [ "$SUCESS" = "Y" ];
                         then
                             VALID="Y"
                             echo "$(OK) File: $j successfully initialized."
                             echo "$(OK) $SEPA" >> $TMPDIR/$j
                             case $j in
                             $PNAME$NORM_PROFIX)
                                 ## PROCESOS CORRIENTES Y SU INFORMACION (/proc)
                                 echo "$(OK) Files in /proc" >> $TMPDIR/$j
                                 echo "$(OK)
$(ls /proc)
                                 " >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) Output of TOP" >> $TMPDIR/$j
                                 if [ -z "$TOPFLAGS" ];
                                 then
                                     export TOPFLAGS="-n 1"
                                 fi
                                 echo "$(OK)
$(top $TOPFLAGS)
                                 " >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) Output of FREE" >> $TMPDIR/$j
                                 echo "$(OK)
$(free)
                                 " >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) SUCCESS." >> $TMPDIR/$j
                                 ;;
                             $KNAME$NORM_PROFIX)
                             ## COSAS DEL KERNEL
                                 echo "$(OK) Kernel version" >> $TMPDIR/$j
                                 echo "$(OK)
$(uname -a)
                                 " >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) GCC and Host" >> $TMPDIR/$j
                                 echo "$(OK)
$(cat /proc/version)
                                 " >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) Modules (/proc/modules)" >> $TMPDIR/$j
                                 echo "$(OK)
$(cat /proc/modules)
                                 " >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) CMDLINE" >> $TMPDIR/$j
                                 echo "$(OK)
$(cat /proc/cmdline)
                                 " >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) DMESG" >> $TMPDIR/$j
                                 echo "$(OK)
$(dmesg)
                                 " >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 ;;
                             $CNAME$NORM_PROFIX)
                                 echo "$(OK) Logcat RADIO"  >> $TMPDIR/$j
                                 echo "$(OK) 
$(logcat -b radio -v time -d)
                                 "  >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) Logcat EVENTS"  >> $TMPDIR/$j
                                 echo "$(OK) 
$(logcat -b events -v time -d)
                                 "  >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) Logcat MAIN"  >> $TMPDIR/$j
                                 echo "$(OK) 
$(logcat -b main -v time -d)
                                 "  >> $TMPDIR/$j
                                 ;;
                             $CPUNAME$NORM_PROFIX)
                                 echo "$(OK) CPU Info" >> $TMPDIR/$j
                                 echo "$(OK) 
$(cat /proc/cpuinfo)
                                 " >> $TMPDIR/$j
                                 ;;
                             $BNAME$NORM_PROFIX)
                                 echo "$(OK) Copy of ../build.prop" >> $TMPDIR/$j
                                 echo "$(OK) 
$(cat /system/build.prop)
                                 " >> $TMPDIR/$j
                                 ;;
                             $LASTKMSG$NORM_PROFIX)
                                 echo "$(OK) last_kmgs dump" >> $TMPDIR/$j
                                 echo "$(OK) 
$(cat /proc/last_kmgs)
                                 " >> $TMPDIR/$j
                                 ;;
                             $SYSCTL$NORM_PROFIX)
                                 EX=""
                                 ls /etc/sysctl.conf &> /dev/null && EX="Y" || EX="N"
                                 if [ "$EX" = "Y" ];
                                 then
                                     cat /etc/sysctl.conf >> $TMPDIR/$j && echo "$(OK) Dump file $j successfully" || "$(ERR) Can't dump $j" 
                                 else
                                     echo "$(ERR) /etc/sysctl.conf: No such file"
                                 fi
                                 ;;
                             $DF$NORM_PROFIX)
                                 echo "$(OK) Output of DF" >> $TMPDIR/$j
                                 echo "$(OK) 
$(df)
                                 " >> $TMPDIR/$j
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) Output of 'mount'" >> $TMPDIR/$j
                                 echo "$(OK)
$(mount)
                                 " >> $TMPDIR/$j
                                 ;;
                             *)
                                 echo "$(ERR) $j: No such file. Please add it to the REG_LIST."
                                 ;;
                             esac
                             if [ "$VALID" = "Y" ];
                             then
                                 echo "$(OK) $SEPA" >> $TMPDIR/$j
                                 echo "$(OK) EOF" >> $TMPDIR/$j
                                 echo "$(OK) $j: finished"
                            fi
                         else
                             echo "$(ERR) Can't access to $j."
                         fi
                    done
                    cp /proc/config.gz $TMPDIR/config.gz && echo "$(OK) config.gz found and copied" || echo "$(OK) /proc/config.gz: config.gz support disabled in kernel"
                    cp /proc/filesystems $TMPDIR/filesystems && echo "$(OK) filesystems found and copied" || echo "$(OK) /proc/filesystems: No such file"
                    cp -a /etc/init.d/. $INITD && echo "$(OK) init.d tweaks copied"
                    echo "$(OK) SHA-256 sum: 
$(sha256sum $0)"
                    echo "$(OK) SHA-256 sums: $(sha256sum $TMPDIR/*/*)" > $TMPDIR/sha-sums.txt
                    ## Take an instantanely log and exit.
                    THSDIR=$(pwd)
                    makezip $LOG_PACKED
                    cd $THSDIR && echo "$(OK) Here: $THISDIR"
                    echo "$(OK) Keilyd cycle finished! Sleeping: $SECS seconds!!"
                    if [[ $2 == --snap ]];
                    then
                        echo "$(OK) Snapshot successfully taken, exit now..."
                        export LOCKER="FALSE"
                        break
                    fi
                    sleep $SECS && echo "$(OK) Wait time of $SECS secs successfully finished (c: $SCLEAN))."
                    while [ "$LOCKER" = "TRUE" ];
                    do
                        sleep 5
                        echo "$(WARN) Daemon LOCKED!!!"
                    done
                    echo $(separator)
                    echo ""
                    echo ""
                done
        else
            echo "$(ERR) Can't enter into working directory."
        fi
    fi
elif [[ $1 == --help ]];
then
    echo "Keilyd, a BASH daemon that constantely dumps the system logs in a easy-to-share ZIP file."
    echo "$(OK) Keilyd HELP menu, #$ID."
    echo "This script is only compatible with BASH 4.3.x."
    echo "In order to get Keilyd working, this pre-conditions must be meet:
             1. Keilyd and you are in a Android based device.
             2. Your SDCARD is mounted or symlinked to /sdcard
             3. You have BASH 4.3 installed or symlinked on /system/xbin and it actually works
             4. Your device have init.d {generally using 'run-parts'} support (part of the BusyBox package)
             5. Your device is rooted, and without SELinux.
                    - If your device is protected with SELinux, ensure that the init.d scripts can run
                      in a unrestricted context (like 'init')
             6. The script is launched by run-parts or with ABSOLUTE PATH, partial path are not supported:
                    - './18keily' is INVALID and will return a 'No such file' error
                    - 'init.d/18keily' will return a error.
                    - '/etc/init.d/18keily' OR '/system/etc/init.d/18keily' are permited.
                NOTE: All invoking methods are valid ONLY FOR THE '--help' param.
             "
    echo "By default, this script is in '/etc/init.d/18keily', you can change the directory or the filename,
             and launch keilyd with a 3rd party script, if the avobe conditions are meet.
             "
    echo "Keilyd verify all the environment and exit if there are unmeeted requisites, and tell you what and
          when the things goes wrong."
    echo "You can disable Keilyd without deleting this file by changing ENABLED to any thing but 'Y'."
    echo "Params:
              <none>: Automatic daemon launch, this ensure that the environment is ready.
              --demonize: Runs the daemon mode, but not as a daemon, THIS OPTION IS FORBIDEN.
              --snap: Takes a 'snapshot' of the current logs and updates all the files to the
                      lastest taken iformation.
              --help: Print this help."
    echo "Keilyd allows the user to override several variables using a third-party launch script and the BASH
          environment function, this variables can be override (for now):
              MINS=<int> ; Change the default time that Keily waits to save the info (in minutes).
              FILEDIR=<path> ; Define the path where Keily stores its info (ABSOLUTE PATH ONLY).
              SLIMIT=<int> ; Maximun times that Keily will append info in a single file. When this value is
                             reached, Keily will clean ALL THE FILES, including the daemon log, and others.
              TOPFLAGS=<int> ; In some devices, the default 'top' parameters are not supported, see the daemon
                               log to debug this issue and override this variable as needed.
              ENABLED=<any> ; A value different from <string>'Y' will disable keilyd."
    echo "The logs will be saved in $TMPDIR"
    echo "If you pharse --help, this message will be printed in the terminal stdout."
    echo "NoTengoBattery - 2015"
else
    echo "$(OK) Launched #$ID" >> $DELOG
    echo "$(OK) cmdline: '$0 $@'" >> $DELOG
    echo "$(ERR) Please invoke keilyd with '--demonize' as parameter." >> $DELOG
    echo "Launch keilyd with --help to print a usefull help message."
fi
echo "$(OK) Exit #$ID." >> $DELOG || echo "$(OK) Exit #$ID."